//! Shell completion installation commands
//!
//! Manages installation of hoards shell completions for Fish, Bash, and Zsh.

use anyhow::{Context, Result};
use colored::Colorize;
use std::io::IsTerminal;
use std::path::PathBuf;

/// Completion installation status for a shell
#[derive(Debug)]
pub struct CompletionStatus {
    pub shell: String,
    pub installed: bool,
    pub path: PathBuf,
    pub config_exists: bool,
}

/// Get the completion file path for a shell
fn completion_path(shell: &str) -> Option<PathBuf> {
    let home = dirs::home_dir()?;

    match shell {
        "fish" => Some(home.join(".config/fish/completions/hoards.fish")),
        "bash" => Some(home.join(".local/share/bash-completion/completions/hoards")),
        "zsh" => Some(home.join(".zfunc/_hoards")),
        _ => None,
    }
}

/// Check if a shell's config directory exists (indicates shell is used)
fn shell_config_exists(shell: &str) -> bool {
    let home = match dirs::home_dir() {
        Some(h) => h,
        None => return false,
    };

    match shell {
        "fish" => home.join(".config/fish").exists(),
        "bash" => home.join(".bashrc").exists() || home.join(".bash_profile").exists(),
        "zsh" => home.join(".zshrc").exists(),
        _ => false,
    }
}

/// Detect which shells are available on the system
fn detect_shells() -> Vec<String> {
    let mut shells = Vec::new();

    for shell in &["fish", "bash", "zsh"] {
        if shell_config_exists(shell) {
            shells.push(shell.to_string());
        }
    }

    shells
}

/// Generate completion content for a shell
fn generate_completion(shell: &str) -> Result<String> {
    use clap::CommandFactory;
    use clap_complete::{Shell, generate};

    let shell_enum = match shell {
        "fish" => Shell::Fish,
        "bash" => Shell::Bash,
        "zsh" => Shell::Zsh,
        _ => anyhow::bail!("Unsupported shell: {}", shell),
    };

    let mut cmd = crate::cli::Cli::command();
    let mut buf = Vec::new();
    generate(shell_enum, &mut cmd, "hoards", &mut buf);

    // Add version marker comment at the top
    let version = env!("CARGO_PKG_VERSION");
    let content = String::from_utf8(buf)?;
    let header = format!(
        "# hoards v{} completions\n# Generated by: hoards completions install\n\n",
        version
    );

    Ok(header + &content)
}

/// Get completion status for all shells
pub fn cmd_completions_status() -> Result<()> {
    println!("{}", "Shell Completion Status".bold());
    println!("{}", "-".repeat(50));

    let shells = ["fish", "bash", "zsh"];
    let mut any_installed = false;

    for shell in &shells {
        let path = completion_path(shell).unwrap_or_default();
        let config_exists = shell_config_exists(shell);
        let installed = path.exists();

        let status_icon = if installed {
            any_installed = true;
            "+".green()
        } else if config_exists {
            "-".yellow()
        } else {
            " ".dimmed()
        };

        let shell_status = if !config_exists {
            "(not detected)".dimmed().to_string()
        } else if installed {
            format!("{}", "installed".green())
        } else {
            format!("{}", "not installed".yellow())
        };

        println!("  {} {:6} {}", status_icon, shell, shell_status);

        if installed {
            println!("           {}", path.display().to_string().dimmed());
        }
    }

    println!();

    if !any_installed {
        println!(
            "{} Run {} to install completions",
            ">".cyan(),
            "hoards completions install".yellow()
        );
    }

    Ok(())
}

/// Install completions for specified or detected shells
pub fn cmd_completions_install(shell: Option<String>, force: bool) -> Result<()> {
    let shells = match shell {
        Some(s) => vec![s],
        None => detect_shells(),
    };

    if shells.is_empty() {
        println!("{} No shells detected. Specify a shell:", "!".yellow());
        println!("  hoards completions install fish");
        println!("  hoards completions install bash");
        println!("  hoards completions install zsh");
        return Ok(());
    }

    println!("{} Installing completions...", ">".cyan());
    println!();

    for shell in &shells {
        install_for_shell(shell, force)?;
    }

    println!();
    println!(
        "{} Restart your shell or source the config to activate.",
        ">".cyan()
    );

    Ok(())
}

/// Install completion for a single shell
fn install_for_shell(shell: &str, force: bool) -> Result<()> {
    let path = completion_path(shell).ok_or_else(|| anyhow::anyhow!("Unknown shell: {}", shell))?;

    // Check if already installed
    if path.exists() && !force {
        println!(
            "  {} {} completions already installed (use --force to overwrite)",
            "!".yellow(),
            shell
        );
        return Ok(());
    }

    // Generate completion content
    let content = generate_completion(shell)?;

    // Ensure parent directory exists
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create directory: {}", parent.display()))?;
    }

    // Write completion file
    std::fs::write(&path, &content)
        .with_context(|| format!("Failed to write completion file: {}", path.display()))?;

    println!("  {} {} -> {}", "+".green(), shell, path.display());

    // Zsh needs special handling for fpath
    if shell == "zsh" {
        check_zsh_fpath(&path)?;
    }

    Ok(())
}

/// Check if zsh fpath includes the completion directory
fn check_zsh_fpath(completion_path: &std::path::Path) -> Result<()> {
    let home = dirs::home_dir().unwrap_or_default();
    let zshrc = home.join(".zshrc");

    if !zshrc.exists() {
        return Ok(());
    }

    let content = std::fs::read_to_string(&zshrc).unwrap_or_default();
    let _zfunc_dir = completion_path.parent().unwrap_or(completion_path);

    // Check if fpath already includes .zfunc
    if content.contains(".zfunc") || content.contains("fpath+=") && content.contains("zfunc") {
        return Ok(());
    }

    // Suggest adding fpath
    println!();
    println!(
        "  {} Zsh may need fpath configured. Add to ~/.zshrc:",
        "!".yellow()
    );
    println!("     {}", "fpath+=~/.zfunc".cyan());
    println!("     {}", "autoload -Uz compinit && compinit".cyan());

    // Offer to add automatically
    if std::io::stdout().is_terminal() {
        use dialoguer::Confirm;

        println!();
        let add = Confirm::new()
            .with_prompt("Add fpath to ~/.zshrc automatically?")
            .default(true)
            .interact()?;

        if add {
            let fpath_config = r#"
# Hoards completions (added by hoards)
fpath+=~/.zfunc
autoload -Uz compinit && compinit
"#;

            let mut file = std::fs::OpenOptions::new().append(true).open(&zshrc)?;

            use std::io::Write;
            file.write_all(fpath_config.as_bytes())?;

            println!("  {} Added fpath to ~/.zshrc", "+".green());
        }
    }

    Ok(())
}

/// Uninstall completions for specified or all shells
pub fn cmd_completions_uninstall(shell: Option<String>) -> Result<()> {
    let shells = match shell {
        Some(s) => vec![s],
        None => vec!["fish".into(), "bash".into(), "zsh".into()],
    };

    println!("{} Removing completions...", ">".cyan());
    println!();

    let mut removed_any = false;

    for shell in &shells {
        if let Some(path) = completion_path(shell)
            && path.exists()
        {
            std::fs::remove_file(&path)
                .with_context(|| format!("Failed to remove: {}", path.display()))?;
            println!("  {} Removed {} completions", "-".red(), shell);
            removed_any = true;
        }
    }

    if !removed_any {
        println!("  {} No completions were installed", "!".yellow());
    }

    Ok(())
}
